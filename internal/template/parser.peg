{ 
    package parser


func toAnySlice(v any) ([]any, bool) {
	if v == nil {
		return nil, false
	}
	newV, ok := v.([]any)
	return newV, ok
}
}

Start <- top:Seq EOF {
	return top, nil
} 


Seq <- v:(( IfElse / If / For / TextBlock / Accessor ) Seq / "") {
	vals, ok := toAnySlice(v)
	if !ok {
		return nil, nil
	} else {
		left, _ := vals[0].(node)
		right, _ := vals[1].(node)

		left.setNext(right)

		return left, nil	
	}	
}   

IfElse <- S "if" _ cond:OrCondition _ S _ tr:Seq os:(S "else" _ "if" _ OrCondition _ S _ Seq _)+ el:(S _ "else" _ S  _ Seq _ )? S "end" S {
	other, _ := toAnySlice(os)
	topCondition, _ := cond.(condition)
	topTrue, _ := tr.(node)

	top := &ifNode{condition: topCondition, trueClause: topTrue, baseNode: baseNode{child:nil}}
	toRet := top 

	for _, elseClause := range other {
		elseClauseElems, _ := toAnySlice(elseClause)
		elseCondition, _ := elseClauseElems[5].(condition)
		elseTrue, _ := elseClauseElems[9].(node)
		elseNode := &ifNode{condition: elseCondition, trueClause: elseTrue, baseNode: baseNode{child:nil}}
		top.falseClause = elseNode
		top = elseNode
	}	

	if el != nil {
		elems, _ := toAnySlice(el)
		falseClause, _ := elems[6].(node)
		top.falseClause = falseClause	
	}

	return toRet, nil 

}

If <- S "if" _ cond:OrCondition _ S tr:Seq _ f:(S "else" S _ Seq)? S "end" S {
	// condition, _ := (cond.c.string)
	condition := cond.(condition)
	trueClause, _:= tr.(node)
	var falseClause node 

	if f != nil { 
		vals, _ := toAnySlice(f)
		falseClause, _ = vals[4].(node)
	}

	node := ifNode{condition: condition, trueClause: trueClause, falseClause: falseClause, baseNode: baseNode{child: nil}}
	return &node, nil 
}

For <- S "for" _ vars:ForVars _ "=" _ t:("range" / "props") _ p:AccessPattern _ S _ l:Seq S "end" S {
	stringVars, _ := vars.([]string)
	loop, _ := l.(node)
	forT := string(t.([]byte))
	pattern, _ := p.(string)

	foraa := forNode{ forType: forT == "range", itemName: stringVars[1], indexName: stringVars[0], pattern: pattern, loop: loop, baseNode : baseNode{child: nil}} 
	return &foraa, nil
}

ForVars <- v1:VarName _ "," _ v2:VarName {
	vstr1, _ := v1.(string)
	vstr2, _ := v2.(string)
	return []string{vstr1, vstr2}, nil
}

VarName <- [a-zA-Z]+ {
	varName := string(c.text)
	return varName, nil
}


Accessor <- S t:AccessPattern S  {
	pattern := t.(string)

	node := accessNode{accessPattern: pattern, baseNode: baseNode{child: nil}}
	return &node, nil
}


TextBlock <- t:Text {
	text := t.(string)
	node := textNode{text: text, baseNode: baseNode {child: nil}}
	return &node, nil
}


OrCondition <- base:AndCondition os:( _ "or"  _ AndCondition)* {
	baseCondition, _ := base.(condition)
	others, _ := toAnySlice(os) 



	if others == nil {
		return baseCondition, nil 
	}

	curr := baseCondition

	for _, other := range others {
		components, _ := toAnySlice(other)
		condition, _ := components[3].(condition)	
		top := orCondition{left: curr, right: condition} 
		curr = top
	}


	return curr, nil

}

AndCondition <- base:Condition os:( _ "and" _  Condition)* {
	baseCondition, _ := base.(condition)
	others, _ := toAnySlice(os) 


	if others == nil {
		return baseCondition, nil 
	}

	curr := baseCondition

	for _, other := range others {
		components, _ := toAnySlice(other)
		condition, _ := components[3].(condition)	
		top := andCondition{left: curr, right: condition} 
		curr = top
	}

	return curr, nil

}

Condition <- e:( OfType / Exists / FromElements / ("!")? GroupedCondition) {

	elems, isGroup := toAnySlice(e)

	if !isGroup {
		return e, nil 
	}

	isNegated := elems[0] != nil 
	cond, _ := elems[1].(condition)

	if isNegated {
		return negatedCondition{toNegate: cond}, nil
	} 

	return cond, nil 
	
}

OfType <- p:AccessPattern _ "isa" _ e:TypeExpression {
	elemType, _ := e.([]byte)
	strType := string(elemType)
	pattern, _ := p.(string)
	return ofType{pattern: pattern, typeOf: convertType(strType)}, nil
}

TypeExpression <- "array" / "object" / "number" / "string" / "bool" 

Exists <- "exists" _ p:AccessPattern {
	pattern, _ := p.(string)
	return existsCondition{pattern: pattern}, nil
}


GroupedCondition <- "(" _ cond:OrCondition _ ")" {
	return cond, nil 
}

FromElements <- e:(ConditionElement _ Operator _ ConditionElement / ("!"?) ConditionElement) {
	elems, _ := toAnySlice(e)

	isOperation := len(elems) == 5

	if isOperation {
		left, _ := elems[0].(element)
		right, _ := elems[4].(element)
		operator, _ := elems[2].([]uint8)
		return operatorCondition{left: left, right: right, operator: convertOperator(string(operator))}, nil 
	}
	
	isElem := len(elems) == 2

	if isElem {
		elem, _ := elems[1].(element)
		elemCondition := singleCondition{element: elem}
		if elems[0] == nil {
			return elemCondition, nil
		} else {
			return negatedCondition{toNegate: elemCondition}, nil
		}

	} 

	condition, isCondition := e.(condition)

	if isCondition {
		return condition, nil 
	}

	return nil, errors.New("Invalid condition")
}

ConditionElement <- e:(Constant / AccessElement ) {
	return e, nil
}


Operator <- "=" / "<=" / ">=" / "<" / ">" / "!="

Constant <- ('"' [^$"()]+ '"' / "-"? [0-9]+("." [0-9]+)? / "true" / "false") { 
	text := string(c.text)
	val, tpe, err := textToElem(text)
	if err != nil {
		return "", err 
	}

	return constantElement{constant: val, constType: tpe}, nil 

}

AccessElement <- t:AccessPattern {
	pattern, _ := t.(string)
	return accessElement{pattern: pattern}, nil
}
 
AccessPattern <- !(Special / S) ([a-zA-Z0-9] / "->" / "[" / "]")+ {
	text := string(c.text)
	return text, nil
}

Text <- [^$]+  {
	text :=  string(c.text)
	return text, nil
}

Special <- "for" / "if" / "range" / "props" / "exists" / "end" / "else" 

S <- "$"

_ "whitespace" <- [ \t\r\n]*

EOF <- !.



