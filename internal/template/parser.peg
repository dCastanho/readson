{ 
    package parser


func toAnySlice(v any) ([]any, bool) {
	if v == nil {
		return nil, false
	}
	newV, ok := v.([]any)
	return newV, ok
}
}

Start <- top:Seq EOF {
	return top, nil
} 


Seq <- v:(( If / TextBlock / Accessor ) Seq / "") {
	vals, ok := toAnySlice(v)

	if !ok {
		return nil, nil
	} else {
		left, _ := vals[0].(node)
		right, _ := vals[1].(node)

		left.setNext(right)

		return left, nil	
	}	
}

Expression <- If / Accessor  

If <- S "!if " cond:OrCondition S tr:Seq f:(S "!else" S Seq)? S "!end" S {
	// condition, _ := (cond.c.string)
	condition := cond.(condition)
	trueClause, _:= tr.(node)
	var falseClause node 

	if f != nil { 
		vals, _ := toAnySlice(f)
		falseClause, _ = vals[3].(node)
	}

	node := ifNode{condition: condition, trueClause: trueClause, falseClause: falseClause, baseNode: baseNode{child: nil}}
	return &node, nil 
}


Accessor <- S &[^!] t:AccessPattern S  {
	pattern := t.(string)

	node := accessNode{accessPattern: pattern, baseNode: baseNode{child: nil}}
	return &node, nil
}


TextBlock <- t:Text {
	text := t.(string)
	node := textNode{text: text, baseNode: baseNode {child: nil}}
	return &node, nil
}


OrCondition <- base:AndCondition os:( _ "or"  _ AndCondition)* {
	baseCondition, _ := base.(condition)
	others, _ := toAnySlice(os) 



	if others == nil {
		return baseCondition, nil 
	}

	curr := baseCondition

	for _, other := range others {
		components, _ := toAnySlice(other)
		condition, _ := components[3].(condition)	
		top := orCondition{left: curr, right: condition} 
		curr = top
	}


	return curr, nil

}

AndCondition <- base:Condition os:( _ "and" _  Condition)* {
	baseCondition, _ := base.(condition)
	others, _ := toAnySlice(os) 


	if others == nil {
		return baseCondition, nil 
	}

	curr := baseCondition

	for _, other := range others {
		components, _ := toAnySlice(other)
		condition, _ := components[3].(condition)	
		top := andCondition{left: curr, right: condition} 
		curr = top
	}

	return curr, nil

}

Condition <- e:(FromElements / GroupedCondition) {
	return e, nil
}

GroupedCondition <- "(" _ cond:OrCondition _ ")" {
	return cond, nil 
}

FromElements <- e:(ConditionElement _ Operator _ ConditionElement / ConditionElement) {
	elems, isOperation := toAnySlice(e)

	fmt.Println("eee", e, reflect.TypeOf(e))
	fmt.Println("isOp", isOperation)


	if isOperation {
		left, _ := elems[0].(element)
		right, _ := elems[4].(element)
		operator, _ := elems[2].([]uint8)
		return operatorCondition{left: left, right: right, operator: convertOperator(string(operator))}, nil 
	}
	
	elem, isElem := e.(element)

	fmt.Println("isElem", isElem)

	
	if isElem {
		return singleCondition{element: elem}, nil 
	} 

	condition, isCondition := e.(condition)

	if isCondition {
		return condition, nil 
	}

	return nil, errors.New("Invalid condition")
}

ConditionElement <- e:(Constant / AccessElement ) {
	fmt.Println("elem", e)
	return e, nil
}


Operator <- "=" / "<=" / ">=" / "<" / ">" / "!="

Constant <- ('"' [^$"()]+ '"' / "-"? [0-9]+("." [0-9]+)? / "true" / "false") { 
	text := string(c.text)
	val, tpe, err := textToElem(text)
	if err != nil {
		return "", err 
	}

	return constantElement{constant: val, constType: tpe}, nil 

}

AccessElement <- t:AccessPattern {
	pattern, _ := t.(string)
	return accessElement{pattern: pattern}, nil
}
 
AccessPattern <- ([a-zA-Z0-9] / "->" / "[" / "]")+ {
	text := string(c.text)
	return text, nil
}

Text <- [^$]+ {
	text :=  string(c.text)
	return text, nil
}

S <- "$"

_ "whitespace" <- [ \t\r\n]*

EOF <- !.



